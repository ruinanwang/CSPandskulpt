// Generated by CoffeeScript 1.12.4
(function() {
  pythy.Sound = (function() {
    Sound.SAMPLE_RATE = 44100;

    Sound.mapFloatTo16BitInt = function(sampleValue) {
      return parseInt(sampleValue * 32768);
    };

    Sound.map16BitIntToFloat = function(sampleValue) {
      return sampleValue / 32768;
    };

    Sound.prototype._initializeContext = function() {
      if (window.__$audioContext$__) {
        return;
      }
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      return window.__$audioContext$__ = new window.AudioContext();
    };

    function Sound() {
      var arg0, arg1, i, k, l, onError, onSuccess, ref, ref1, type;
      this._initializeContext();
      this.buffer = null;
      this.channels = [];
      this.playbacks = [];
      onSuccess = arguments[0];
      onError = arguments[1];
      arg0 = arguments[2];
      arg1 = arguments[3];
      type = typeof arg0;
      if (type === 'string' && arg0.trim().length) {
        this.url = window.mediaffi.customizeMediaURL(arg0);
        this.load(onSuccess, onError);
      } else if (type === 'number') {
        arg1 = arg1 || pythy.Sound.SAMPLE_RATE;
        if (arg0 < 0) {
          return onError('Number of samples can not be negative');
        }
        if (arg1 < 0) {
          return onError('Sampling rate can not be negative');
        }
        if (arg0 / arg1 > 600) {
          return onError('Duration can not be greater than 600 seconds');
        }
        this.buffer = __$audioContext$__.createBuffer(2, arg0, arg1);
        for (i = k = 0, ref = this.buffer.numberOfChannels - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          this.channels[i] = this.buffer.getChannelData(i);
        }
        onSuccess && onSuccess(this);
      } else if (arg0 instanceof pythy.Sound) {
        this.buffer = __$audioContext$__.createBuffer(arg0.buffer.numberOfChannels, arg0.getLength(), arg0.getSamplingRate());
        for (i = l = 0, ref1 = arg0.buffer.numberOfChannels - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
          this.channels[i] = arg0.buffer.getChannelData(i);
        }
        onSuccess && onSuccess(this);
      } else {
        throw new Error('Must provide either a url or number of samples with the sample rate optionally');
      }
    }

    Sound.prototype.load = function(onSuccess, onError) {
      var request;
      request = new XMLHttpRequest();
      request.onload = (function(_this) {
        return function() {
          if (request.status !== 200) {
            return onError && onError(request.statusText);
          } else if (!request.response instanceof ArrayBuffer) {
            return onError && onError('File not found or is not of the correct type');
          } else {
            return __$audioContext$__.decodeAudioData(request.response, function(decodedData) {
              var i, k, ref;
              _this.buffer = decodedData;
              for (i = k = 0, ref = _this.buffer.numberOfChannels - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
                _this.channels[i] = _this.buffer.getChannelData(i);
              }
              return onSuccess && onSuccess(_this);
            }, function(error) {
              return onError && onError('File not found or is not of the correct type');
            });
          }
        };
      })(this);
      request.onerror = request.timeout = onError;
      request.open('GET', CodeController.transformUrl(this.url), true);
      request.responseType = 'arraybuffer';
      return request.send();
    };

    Sound.prototype._cloneBuffer = function() {
      var buffer, fromChannel, i, j, k, l, ref, ref1, toChannel;
      buffer = __$audioContext$__.createBuffer(this.buffer.numberOfChannels, this.buffer.length, this.buffer.sampleRate);
      for (i = k = 0, ref = this.buffer.numberOfChannels - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        toChannel = buffer.getChannelData(i);
        fromChannel = this.buffer.getChannelData(i);
        for (j = l = 0, ref1 = fromChannel.length - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
          toChannel[j] = fromChannel[j];
        }
      }
      return buffer;
    };

    Sound.prototype.getUrl = function() {
      return this.url;
    };

    Sound.prototype.play = function(callback) {
      var source;
      source = this._getPlayback(callback ? false : true);
      source.onended = callback;
      return source.start(0);
    };

    Sound.prototype.playBefore = function(time) {
      return this._getPlayback().start(0, 0, time);
    };

    Sound.prototype.playAfter = function(time) {
      return this._getPlayback().start(0, time);
    };

    Sound.prototype.playSelection = function(from, to) {
      return this._getPlayback().start(0, from, to - from);
    };

    Sound.prototype.stop = function() {
      var k, len, playback, ref;
      ref = this.playbacks;
      for (k = 0, len = ref.length; k < len; k++) {
        playback = ref[k];
        playback.stop();
      }
      return this.playbacks = [];
    };

    Sound.prototype.getDuration = function() {
      return this.buffer.duration;
    };

    Sound.prototype.getLength = function() {
      return this.buffer.length;
    };

    Sound.prototype.setLeftSample = function(index, value) {
      return this.channels[0][index] = value;
    };

    Sound.prototype.setRightSample = function(index, value) {
      return this.channels[1][index] = value;
    };

    Sound.prototype.getLeftSample = function(index) {
      return this.channels[0][index];
    };

    Sound.prototype.getRightSample = function(index) {
      return this.channels[1][index];
    };

    Sound.prototype.getSample = function(channelNum, index) {
      return this.channels[channelNum][index];
    };

    Sound.prototype.getSamplingRate = function() {
      return this.buffer.sampleRate;
    };

    Sound.prototype._getPlayback = function(clone) {
      var source;
      source = window.__$audioContext$__.createBufferSource();
      this.playbacks.push(source);
      source.buffer = clone ? this._cloneBuffer() : this.buffer;
      source.connect(window.__$audioContext$__.destination);
      return source;
    };

    Sound.prototype._getMimeType = function(filename) {
      switch (this._getExtension(filename)) {
        case 'mp3':
          return 'audio/mpeg';
        case 'wav':
          return 'audio/wav';
      }
    };

    Sound.prototype._getExtension = function(filename) {
      return filename.split('.').pop();
    };

    Sound.prototype._replaceExtension = function(filename, ext) {
      return filename.split('.')[0] + ext;
    };

    Sound.prototype.save = function(filename, continueWith) {
      var blob, samples, type;
      type = this._getMimeType(filename);
      switch (this.buffer.numberOfChannels) {
        case 1:
          samples = this.buffer.getChannelData(0);
          break;
        case 2:
          samples = this._interleave(this.buffer.getChannelData(0), this.buffer.getChannelData(1));
          break;
        default:
          throw new Error('Pythy does not support more than 2 channels');
      }
      blob = new Blob([this._encodeWAV(samples)], {
        type: type
      });
      if (type === 'audio/mpeg') {
        filename = this._replaceExtension(filename, '.wavmp3');
      }
      return pythy.uploadFileFromBlob(filename, blob).done(function(e, data) {
        return continueWith(e);
      });
    };

    Sound.prototype._interleave = function(inputL, inputR) {
      var index, inputIndex, length, result;
      length = inputL.length + inputR.length;
      result = new Float32Array(length);
      index = 0;
      inputIndex = 0;
      while (index < length) {
        result[index++] = inputL[inputIndex];
        result[index++] = inputR[inputIndex];
        inputIndex++;
      }
      return result;
    };

    Sound.prototype._floatTo16BitPCM = function(output, offset, input) {
      var k, len, results, s, value;
      results = [];
      for (k = 0, len = input.length; k < len; k++) {
        value = input[k];
        s = Math.max(-1, Math.min(1, value));
        output.setInt16(offset, (s < 0 ? s * 0x8000 : s * 0x7FFF), true);
        results.push(offset += 2);
      }
      return results;
    };

    Sound.prototype._writeString = function(view, offset, string) {
      var i, k, ref, results;
      results = [];
      for (i = k = 0, ref = string.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        results.push(view.setUint8(offset + i, string.charCodeAt(i)));
      }
      return results;
    };

    Sound.prototype._encodeWAV = function(samples) {
      var view;
      view = new DataView(new ArrayBuffer(44 + samples.length * 2));
      this._writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + samples.length * 2, true);
      this._writeString(view, 8, 'WAVE');
      this._writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, this.buffer.numberOfChannels, true);
      view.setUint32(24, this.buffer.sampleRate, true);
      view.setUint32(28, this.buffer.sampleRate * 4, true);
      view.setUint16(32, this.buffer.numberOfChannels * 2, true);
      view.setUint16(34, 16, true);
      this._writeString(view, 36, 'data');
      view.setUint32(40, samples.length * 2, true);
      this._floatTo16BitPCM(view, 44, samples);
      return view;
    };

    return Sound;

  })();

}).call(this);
